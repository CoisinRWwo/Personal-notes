## 微服务架构

![image-20230819101147701](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819101147701.png)

### 微服务架构和微服务

**微服务架构**：微服务架构是一种具体的设计实现或者设计方案， 是将复杂的系统使用组件化的方式进行
拆分，并使用轻量级通讯方式进行整合的一-种设计方法。

**微服务**：微服务是微服务架构具体的实现方案，是通过微服务架构设计方法拆分出来的一个独立的组件
化的小应用。

微服务架构定义的精髓，可以用一-句话来描述，那就是**"分而治之，合而用之”**。将复杂的系统进行拆分
的方法，就是"分而治之”。分而治之，可以让复杂的事情变的简单，这很符合我们平时处理问题的方
法。使用轻量级通讯等方式进行整合的设计， 就是"合而用之”的方法，合而用之可以让微小的力量变动
强大。



### 什么是微服务架构

微服务架构是将一个单- -应用程序开发为一-组小型服务的方法，每个服务运行在自己的进程中，服务间
通信采用的轻量级通信机制(通常用HTTP资源API)，这些服务围绕业务能力构建并且可通过全自动部
署机制独立部署。这些服务公用一个最小型的集中式的管理，服务可用不同的语言进行开发，使用不同
的数据储存技术。

在了解微服务之前首先看看单体架构。

单体架构在中小企业内部用的是非常多的，当业务不复杂，团队规模不大的时候，单体架构比微服务架
构具有更高的生产率。

**注意**:下面示例中的服务器和数据库也可以使用docker容器实现



#### 单体架构的程序部署在单台服务器

这种架构是目前中小企业用的最多的架构。其中web服务(nginx) 、网站程序、静态资源(图片)、数
据库(Mysql、Redis)都在一 台服务器上面。如果每天网站的访问IP在5万以下这种架构完全可以应付(服
务器配置也有关系)

![image-20230819100548757](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819100548757.png)



#### 单体架构的程序部署在多台服务器(负载均衡)

![image-20230819100711433](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819100711433.png)



#### 单体架构的程序部署在多台服务器(负载均衡+主从数据库)

![image-20230819100819327](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819100819327.png)



#### 微服务架构

**微服务架构**:通俗的讲就是把单体架构项目抽离成多个项目(服务)， 部署到多台服务器。

如果用”茶壶煮饺子”来打比方的话，原来我们是在一个茶壶里煮很多个饺子， 现在(微服务化之后)则
基本上是在一个茶壶煮一 个饺子， 而这些饺子就是服务的功能，茶壶则是将这些服务功能打包交付的服
务单元。

![image-20230819100955603](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819100955603.png)

![image-20230819101010350](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819101010350.png)

![image-20230819101104924](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819101104924.png)



### 微服务架构和单体式架构区别



#### 单体式架构服务

**单体架构的优点:**

1、部署简单:由于是完整的结构体，可以直接部署在一个服务器 上即可

2、技术单一:项目不需要复杂的技术栈，往往一套熟悉的技术栈就可以完成开发

3、用人成本低:单个程序员可以完成业务接口到数据库的整个流程

4、项目管理相对较易; 

5、测试相对简单直观;

6、应用开发相对简单; 

7、横向扩展容易. 



**单体架构的缺点:**

1、系统启动慢，-一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动，重启周
期边长;

2、系统错误隔离性差，可用性差，任何一个模块的错误可能导致整个系统的宕机;

3、可伸缩性差，系统的扩容只能对整个应用扩容，不能做到对整个功能点进行扩容;

4、线上问题修复时间长，任何一个线上问题修复需要对整个应用系统进行全面升级;

5、交付周期长(需求>设计->开发>测试>现场实施部署，就传统性质的企业而言);



#### 微服务

**微服务的优点**

1.易于开发和维护: -一个服务只关注一个特定的业务功能， 所以它业务清晰，代码量少。开发和维
护单个微服务相当简单。而整个应用是若干个微服务构建而成的，所以整个应用在被维持在一个可控的
状态;

2.单个服务启动快:单个服务代码量少，所以启动快;

3.局部修改易部署:单个应用只要有修改，就得重新部署整个应用，微服务解决了这个问题。- -般
来说，对某个微服务进行修改，只需要重新部署这个服务即可;

4.技术栈不受限:在微服务架构中，可以结合业务和团队的特点,合理选用技术栈。例如有些服务可
以使用关系型数据库Mysql,有的服务可以使用非关系型数据库redis。甚至可根据需求，部分服务使用
JAVA开发，部分微服务使用Node.js开发

5.按需收缩:可根据需求，实现细粒度的扩展。例如，系统中的某个微服务遇到了瓶颈，可以结合
微服务的特点，增加内存，升级CPU或增加节点。





## RPC架构



### RPC的概念

**RPC(Remote Procedure call Protocol)**，是远程过程调用的缩写，通俗的说就是调用远处的一个
函数。与之相对应的是本地函数调用，我们先来看一下本地函数调用。当我们写下如下代码的时候: 

规则

```go
result := Add(1,2)
```

我们知道，我们传入了1，2两个参数，调用了本地代码中的一个Add函数， 得到result这个返回值。 这
时参数，返回值，代码段都在一个进程空间内， 这是本地函数调用。

![image-20230819101729767](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819101729767.png)



### RPC入门

我们使用微服务化的一个好处就是:

1、不限定服务的提供方使用什么技术选型，能够实现公司跨团队的技术解耦，

2、每个服务都被封装成进程。彼此”独立"。

3、使用微服务可以跨进程通信

![image-20230819101813962](./%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8.assets/image-20230819101813962.png)

RPC协议可以让我们实现不同语言的直接相互调用。在互联网时代，RPC已经和IPC(进程间通信)-样成为一个不可或缺的基础构件。

IPC:进程间通信

RPC:远程进通信- - 一应用层协议 (http协议同层)。底层使用TCP实现。



在golang中实现RPC非常简单，有封装好的官方库和一些第三方库提供支持。Go RPC可以利用tcp或http来传递数据，可以对要传递的数据使用多种类型的编解码方式。golang官方的net/rpc库使用encoding/gob进行编解码，支持**tcp或http**数据传输方式，由于其他语言不支持gob编解码方式，所以使用net/rpc库实现的RPC方法没办法进行跨语言调用。



golang官方还提供了net/rpc/jsonrpc库实现RPC方法，JSON RPC采用JSON进行数据编解码，因而支持
跨语言调用。**但目前的jsonrpc库是基于tcp协议实现的，暂时不支持使用http进行数据传输**。



除了golang官方提供的rpc库，还有许多第三方库为在golang中实现RPC提供支持，大部分第三方rpc库
的实现都是使用protobuf进行数据编解码，根据protobuf声明文件自动生成rpc方法定义与服务注册代
码，在golang中可以很方便的进行rpc服务调用。



#### 服务端

```go
package main

import (
	"fmt"
	"net"
	"net/rpc"
)

// 定义一个远程调用的方法
type Hello struct {
}

// 方法只有两个可序列化的参数，其中第二个参数是指针类型
func (receiver Hello) SayHello(request string, response *string) error {
	*response = "你好" + request
	return nil
}

func main() {
	//注册RPC服务
	err1 := rpc.RegisterName("hello", Hello{})
	if err1 != nil {
		fmt.Println(err1)
	}
	//监听端口
	listener, err2 := net.Listen("tcp", "127.0.0.1:8080")
	if err2 != nil {
		fmt.Println(err2)
	}

	//应用推出的时候关闭监听端口
	defer listener.Close()

	for {
		fmt.Println("开始建立链接")
		//建立连接
		accept, err3 := listener.Accept()
		if err3 != nil {
			fmt.Println(err3)
		}

		//绑定服务
		rpc.ServeConn(accept)
	}
}

```



#### 客户端

```go
package main

import (
	"fmt"
	"net/rpc"
)

func main() {
	//通过rpc.Dial和rpc微服务端建立连接
	dial, err1 := rpc.Dial("tcp", "127.0.0.1:8080")
	if err1 != nil {
		fmt.Println(err1)
	}
	//当客户端退出的时候关闭连接
	defer dial.Close()

	//调用远程函数
	var reply string
	err2 := dial.Call("hello.SayHello", "客户端", &reply)
	if err2 != nil {
		fmt.Println(err2)
	}

	//获取微服务返回的数据
	fmt.Println(reply)
}

```

