## 数据表示

- 原码

- 反码

- 补码

- 移码

|      | 数值1     | 数值-1    | 1-1       |
| ---- | --------- | --------- | --------- |
| 原码 | 0000 0001 | 1000 0001 | 1000 0010 |
| 反码 | 0000 0001 | 1111 1110 | 1111 1111 |
| 补码 | 0000 0001 | 1111 1111 | 0000 0000 |
| 移码 | 1000 0001 | 0111 1111 | 1000 0000 |



### 浮点数运算

浮点数表示：**N = M*R^e**

其中M称为尾数，e是指数，R为基数。



例子：

1000  -->  1.0 * 10^3       119  -->  1.19 * 10^2

以上两个数相加，将低指数转为高指数：(1.0 * 10^3) + (0.119 * 10^3) = 1.119 * 10^3

注：要注意小数点左边的数字要保持在一位。



## 计算机结构

![image-20230410141421347](note.assets/image-20230410141421347.png)

### 结构分类 Flynn

![image-20230410141506148](note.assets/image-20230410141506148.png)



### CISC与RISC

![image-20230410141552460](note.assets/image-20230410141552460.png)



## 流水线

### 概念

![image-20230410141646174](note.assets/image-20230410141646174.png)



### 流水线计算

- 流水线周期为执行时间最长的一段
- 流水线计算公式：
  - 一条指令执行时间 +（指令条数 - 1）* 流水线周期
  - 理论公式：(t1 + t1 + …… + tk) + (n-1) * 流水线周期
  - 实践公式：(k+n-1) * 流水线周期 (其中k指的是几部分操作)

![image-20230410142927048](note.assets/image-20230410142927048.png)

![image-20230410142936522](note.assets/image-20230410142936522.png)

理论公式：(2+2+1) + (100-1) * 2 = 203

实践公式：(3 + 100 - 1) * 2 = 204

注：在选项中有理论公式的答案优先选择，没有则选择实践公式



### 流水线吞吐率计算

![image-20230410143416308](note.assets/image-20230410143416308.png)

以上一案列的计算结果进行计算：

TP = 100 / 203

最大吞吐率：1/2



### 流水线加速比

![image-20230410143631712](note.assets/image-20230410143631712.png)

以之前的流水线计算结果进行计算：

**S = (2+2+1)*100 / 203**



### 流水线的效率

![image-20230410143843568](note.assets/image-20230410143843568.png)

**E = (t + t + t + 3t) * 4 / 15t * 4 = 24t / 60t**



## 层次存储结构

![image-20230410144247171](note.assets/image-20230410144247171.png)

其中cache按k为单位，是1024k

内存为G或M，也是1024	



### Cache 概念

![image-20230410144401002](note.assets/image-20230410144401002.png)

假设Cache命中率为95%，Cache的周期时间为1ns，主存储器周期时间为1ms = 1000ns

平均周期则为：**1ns * 95% + (1 - 95%) * 1000ns = 50.95ns**



### 局部性原理

- 时间局部性
- 空间局部性
- 工作集原理：工作集是进程运行时被频繁访问的页面集合

时间局部性例：

```
int i,s=0;
for(i=1;i<1000;i++)
	for(j=1; j<1000:j++)
		s+=j;
printf("结果为:%d", s)
即刚访问完的数据再次访问
```

空间局部性以数组为例：不停的对刚创建进行初始化的时候



### 主存 - 分类

![image-20230410145130166](note.assets/image-20230410145130166.png)



### 主存 - 编址

![image-20230410145216040](note.assets/image-20230410145216040.png)

例子：

![image-20230410145224721](note.assets/image-20230410145224721.png)