## 数据表示

- 原码

- 反码

- 补码

- 移码

|      | 数值1     | 数值-1    | 1-1       |
| ---- | --------- | --------- | --------- |
| 原码 | 0000 0001 | 1000 0001 | 1000 0010 |
| 反码 | 0000 0001 | 1111 1110 | 1111 1111 |
| 补码 | 0000 0001 | 1111 1111 | 0000 0000 |
| 移码 | 1000 0001 | 0111 1111 | 1000 0000 |



### 浮点数运算

浮点数表示：**N = M*R^e**

其中M称为尾数，e是指数，R为基数。



例子：

1000  -->  1.0 * 10^3       119  -->  1.19 * 10^2

以上两个数相加，将低指数转为高指数：(1.0 * 10^3) + (0.119 * 10^3) = 1.119 * 10^3

注：要注意小数点左边的数字要保持在一位。



## 计算机结构

![image-20230410141421347](note.assets/image-20230410141421347.png)

### 结构分类 Flynn

![image-20230410141506148](note.assets/image-20230410141506148.png)



### CISC与RISC

![image-20230410141552460](note.assets/image-20230410141552460.png)



## 流水线

### 概念

![image-20230410141646174](note.assets/image-20230410141646174.png)



### 流水线计算

- 流水线周期为执行时间最长的一段
- 流水线计算公式：
  - 一条指令执行时间 +（指令条数 - 1）* 流水线周期
  - 理论公式：(t1 + t1 + …… + tk) + (n-1) * 流水线周期
  - 实践公式：(k+n-1) * 流水线周期 (其中k指的是几部分操作)

![image-20230410142927048](note.assets/image-20230410142927048.png)

![image-20230410142936522](note.assets/image-20230410142936522.png)

理论公式：(2+2+1) + (100-1) * 2 = 203

实践公式：(3 + 100 - 1) * 2 = 204

注：在选项中有理论公式的答案优先选择，没有则选择实践公式



### 流水线吞吐率计算

![image-20230410143416308](note.assets/image-20230410143416308.png)

以上一案列的计算结果进行计算：

TP = 100 / 203

最大吞吐率：1/2



### 流水线加速比

![image-20230410143631712](note.assets/image-20230410143631712.png)

以之前的流水线计算结果进行计算：

**S = (2+2+1)*100 / 203**



### 流水线的效率

![image-20230410143843568](note.assets/image-20230410143843568.png)

**E = (t + t + t + 3t) * 4 / 15t * 4 = 24t / 60t**



## 层次存储结构

![image-20230410144247171](note.assets/image-20230410144247171.png)

其中cache按k为单位，是1024k

内存为G或M，也是1024	



### Cache 概念

![image-20230410144401002](note.assets/image-20230410144401002.png)

假设Cache命中率为95%，Cache的周期时间为1ns，主存储器周期时间为1ms = 1000ns

平均周期则为：**1ns * 95% + (1 - 95%) * 1000ns = 50.95ns**



### 局部性原理

- 时间局部性
- 空间局部性
- 工作集原理：工作集是进程运行时被频繁访问的页面集合

时间局部性例：

```
int i,s=0;
for(i=1;i<1000;i++)
	for(j=1; j<1000:j++)
		s+=j;
printf("结果为:%d", s)
即刚访问完的数据再次访问
```

空间局部性以数组为例：不停的对刚创建进行初始化的时候



### 主存 - 分类

![image-20230410145130166](note.assets/image-20230410145130166.png)



### 主存 - 编址

![image-20230410145216040](note.assets/image-20230410145216040.png)

例子：

![image-20230410145224721](note.assets/image-20230410145224721.png)

先将C7FFFH补1，就变成C8000H。

然后C8000H-AC000H,得1C000H。

将结果转换为十进制，得114688，去除1024，得112K个地址单元。

内存块是 112 * 16 。

所以是（112K * 16） / （28 * 16 * x），得4 



## 磁盘结构与参数

![image-20230412191652581](note.assets/image-20230412191652581.png)

![image-20230412191831914](note.assets/image-20230412191831914.png)

![image-20230412192411250](note.assets/image-20230412192411250.png)

处理11个记录得最长时间为366ms

![image-20230412192715380](note.assets/image-20230412192715380.png)

最短则为66ms



## 总线

![image-20230412192827099](note.assets/image-20230412192827099.png)



## 系统可靠性分析 

### 串联系统与并联系统

![image-20230412193157414](note.assets/image-20230412193157414.png)

![image-20230412193404023](note.assets/image-20230412193404023.png)



### 模冗余系统与混合系统

![image-20230412193558391](note.assets/image-20230412193558391.png)

![image-20230412193651514](note.assets/image-20230412193651514.png)



## 差错控制- CRC与海明校验码

![image-20230412193722349](note.assets/image-20230412193722349.png)

![image-20230412194641696](note.assets/image-20230412194641696.png)

![image-20230412194948963](note.assets/image-20230412194948963.png)

![image-20230412195333994](note.assets/image-20230412195333994.png)

![image-20230412195530622](note.assets/image-20230412195530622.png)



## 操作系统

### 概述

![image-20230412195614486](note.assets/image-20230412195614486.png)

![image-20230412195827033](note.assets/image-20230412195827033.png)



### 进程管理 

#### 进程的状态

![image-20230412195934265](note.assets/image-20230412195934265.png)



#### 前趋图

![image-20230412200439182](note.assets/image-20230412200439182.png)

 

#### 进程的同步与进制

![image-20230412200652800](note.assets/image-20230412200652800.png)

![image-20230412200947221](note.assets/image-20230412200947221.png)



#### PV操作

![image-20230412201154339](note.assets/image-20230412201154339.png)

**P操作是申请资源，S减1小于0说明S小于1，证明当前没有可申请的资源，所以这个进程要进入阻塞状态，反之就是有可使用的资源，可继续执行**

**s就像是临界资源数量，为了防止随机执行导致进程队列满，当执行v操作释放资源的时候，需要看当前进程队列中是否有进程在排队等候，所以小于等于0的时候直接调度进程从S<0语句下面执行**

![image-20230412201557484](note.assets/image-20230412201557484.png)

![image-20230412202043679](note.assets/image-20230412202043679.png)

例：

![image-20230412202212960](note.assets/image-20230412202212960.png)

![image-20230412202726251](note.assets/image-20230412202726251.png)

![image-20230412203322240](note.assets/image-20230412203322240.png)



#### 死锁问题

![image-20230412203505425](note.assets/image-20230412203505425.png)

![image-20230412203737323](note.assets/image-20230412203737323.png)