## 了解数据结构的基本概念

  **数据元素**(Data Element)是数据的**基本单位**，在计算机程序中通常作为一个整体进行考虑和处理。

  但它还可以分割成若干个具有不同属性的项（字段）。数据元素一般由一个或多个**数据项**组成。



---



## 了解数据的逻辑结构、存储结构、算法的概念。

 **数据结构**(Data Structure)：指**数据元素**之间的关系，按照某种关系组织起来，以一定的方式存储，并在这些数据上定义了一个运算的集合。

数据元素都**不是孤立的存在**，他们之前存在某种关系，这种相互关系就称为结构，带有结构的数据对象称为**数据结构**。



数据结构分为： 

​            逻辑结构：	  集合（无关联）

​                    				线性结构（1:1）

​                    				树形结构（1:n）（非线性结构）

​                    				图形结构（m:n）（非线性结构）

​            物理(存储)结构：	  顺序（连接）（数组）

​                    		                  链表（不一定连接）



**算法**是对某一特定问题求解步骤的描述

在计算机系统中，算法是由若干条指令组成的有穷序列，其中每一条指令表示计算机的一个或多个操作。

算法满足以下五个性质：

1.**输入**：算法执行前输入量给算法

2.**输出**：算法对输入数据处理的结果

3.**有限性**：执行有限步骤后结束，必须在有限的时间内完成（程序可以不满足有限性）

4.**确定性**：每一步骤都有明确的含义。

5.**可行性**：描述的每一个操作，都可通过以实现的基本运算，执行有限次来完成。

 算法的设计要求：

​     高效性：算法的效率，是指算法执行**时间和占用**的储存空间，如果对于同一个问题有多个算法，可供选择，应尽可能选择执行时间短的、**占用空间少**的算法



---



## 理解时间复杂度、空间复杂度的概念。

时间效率

  一个算法运行所需要的时间与算法中语句执行的次数成正比，如果算法中语句重复执行的次数越多，所需要的时间也就越多。

重复执行的次数——————语句频度

时间量度————————时间复杂度T(n)=O(f(n))

1.1.**常数阶**:

```c
int a=1,b=1,sum;           //执行一次
sum=a+b;                     //执行一次
printf("%d",sum);          //执行一次
```

上面的算法f(n)=3,可知该算法的时间复杂度是一个常数阶，对于像此类的算法时间复杂度，我们都以O(1)表示，而不是O(3)表示，统一表示为**O(1)**.

1.2.**线性阶**：

```c
int i;
for(i=0;i<n;i++)                   //执行n次
```

可知上述的算法时间复杂度就是用**O(n)**表示，这就代表线性阶。

 1.3.**对数阶**：

```c
int count = 1;
while （count < n）
{
    count = count * 2;
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```

每次count乘2距离n就更近，也就是说有多少2相乘后会大于n，然后退出循环，2^x=n 得到x=log2n，时间复杂度为**O(logn)**

1.4.**平方阶**：

```c
//第一种循环：
int i,j;
for(i=0;i<n;i++)
{
	for(j=0;j<n;j++)
	{
	}
}

//第二种循环：
int i,j;
for(i=0;i<n;i++)
{
	for(j=i;j<n;j++)
	{
	}
}

```

当这样的表达式时，我们会将其的算法时间复杂度用O(n^2)表示

<img src="https://img-blog.csdnimg.cn/20201010230826879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyODI4,size_16,color_FFFFFF,t_70#pic_center">



---



## 理解递归的概念

**若一个算法直接地或间接地调用自己**，则称这个算法是递归的算法



---

## 掌握树的表示法，包括父亲结点数组表示法、儿子链表表示法、左儿子右兄弟表示法。 

**父节点数组表示法**：

![image-20211009133011126](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009133011126.png)

**儿子链表表示法**：

![image-20211009134656969](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009134656969.png)

**左儿子右兄弟表示法**：

![image-20211009140107363](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009140107363.png)

---



## 理解二叉树的定义和术语、性质。

树的定义：

  树是n(n>=0)个结点的有限集合T

  当n=0称为空树，否则，称为非空树。



在任意一颗非空树中：

  1.有且仅有一个称为**根（root）**的结点。

  2.当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1, T2，…..Tm,其中每:个集合本身**又是一棵树**，被称作**这个根的子树**。

注：树的定义具有递归性，即树中还有树。



 固有特性：

 1.**空树**是树的特例;

 2.非空树中至少有一个结点，称为树的根，只有**根结点**的树称为**最小树**;

 3.在含有多个结点的树中，除根结点外，其余结点构成若干棵**子树**，且各子树间互不相交。



树的基本术语：

**结点**：包含一个数据元素及若干指向其子树的分支。

**结点及树的度**：结点拥有子树的**个数**称为结点的度。树的度是指树内各结点度的**最大值**。

**叶子或终端结点**：是指度为**零**的结点。

**结点的孩子和双亲**：一个结点的**各子树的根**称为该结点的孩子，这个结点称为其孩子的双亲。

**兄弟**：**同一双亲**的孩子之间互为兄弟。

 

二叉树是一种特殊的树形结构。

特点:

   每个结点至多有两棵子树 (即二叉树中不存在度大于2的结点)，二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树的性质：

性质一：高度为 h >= 0 的二叉树至少有h+1个结点

性质二：高度不超过h的二叉树至多有2^(h+1) - 1个结点，二叉树第n层上的结点数目最多为2^n

性质三：含有n>=1个基点的二叉树的高度之多为n-1。

性质四：含有n>=1个结点的二叉树的高度至少为[logn]，英雌其高度为（logn）



满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树 。

完全二叉树：深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树 。

完全二叉树的特点是叶子结点只可能出现在层序最大的两层上，并且某个结点的左分支下子孙的最大层序与右分支下子孙的最大层序相等或大1  。

满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树



二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。

<img src="https://images0.cnblogs.com/i/497634/201403/270929530778327.jpg">

---



## 掌握二叉树的存储结构，包括顺序存储实现和指针实现。

顺序存储是用一组连续的存储单元存储二叉树的数据元素。

在一棵具有n个结点的完全二叉树中，从根结点起，自上层到下层，每层从左至右地给出所有结点的编号，就能得到一个足以反映整个二叉树结构的线性序列。

![image-20211009143351890](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009143351890.png)



---



## 掌握二叉树的遍历算法及其应用。

DLR:**先序遍历**(Preorder Traverse, 亦称前序遍历)（中左右）

----------访问根结点的操作发生在遍历其左右子树之前。

LDR:**中序遍历**(Inorder Traverse )（左中右）

----------访问根结点的操作发生在遍历其左右子树之中。

LRD:**后序遍历**(Postorder Traverse )（左右中）

----------访问根结点的操作发生在遍历其左右子树之后。

注意:由于访问是根据根结点D操作位置命名，所以DLR、 LDR和LRD分别又称为先根遍历、中根遍历和后根遍历。



### **二叉排序树**

 二叉排序树（二叉搜索树）是利用二叉树的结构特点来实现排序，把给定的一组无序元素按一定的规则构造成一棵二叉树，使其在中序遍历下是有序的。

定义：

 二叉排序树或是空树，或是具有下述性质的二叉树:

若其左子树非空，则其左子树上的所有结点的数据值均小于根结点的数据值;

若其右子树非空，则其有子树上所有结点的数据值均大于或等于根结点的数据值。

左子树和右子树又各是一棵二叉排序树。

![image-20211009143830067](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\20190311150104225.png)



---



## **树，森林与二叉树之间的转换**

 树、森林与二叉树之间可以相互转换。由于二叉树结构简单，相应的处理算法也比较简单，所以在处理树或森林时，可以先将其转换成二叉树，用二叉树的处理算法进行处理。

必要时，也可以将由树转换成的二叉树还原成原来的树结构。

![image-20211009144438407](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009144438407.png)

二叉树（左儿子右兄弟）：

![image-20211009145608027](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009145608027.png)

森林：

![image-20211009145902013](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009145902013.png)

树转换成二叉树后根结点没有右子树，故**只有根结点没有右子树的二叉树才能转换成一棵树**。转换步骤如下:

(1) 使二叉树B的根作为转换后树T的根;

(2)对于所有已经转换过的结点和尚未转换过的结点s，

反复做下面两步:

①如果结点s在B中是结点f的左孩子，在T中s作为f的第 一个孩子:

②如果结点s在B中是结点的右孩子，在T中s作为的兄弟，即作为之双亲的另一个孩子，这个孩子紧靠在的右侧。

---

## 掌握哈夫曼树及其应用

 **哈大曼树** (Huffman)又称最优二叉树，是一类带权路径长度最短的树，这种树在信息检索中很有用。

 **结点间的路径长度**: 树中一个结点到另一个结点之间分支数目称为这对结点之间的路径长度。

 **树的路径长度**: 树的根结点到树中每一结点的路径长度之和。

![image-20211009150146715](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009150146715.png)

**带权路径长度**: 从根结点到某结点的路径长度与该结点上权的乘积。

**树的带权路径长度**: 树中所有叶子结点的带权路径长度之和。

![image-20211009150755656](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009150755656.png)

---

## 了解线索树的概念。

   引入两个区分标志Itag和rtag区分二叉链表中各结点的孩子指针和线索:

Itag=0: Ichild指示该结点的**左孩子**。

ltag=1: Ichild指示 该结点的**前驱**。

rtag=0: rchild指示 该结点的**右孩子**。

rtag=1: rchild指示该结点的**后继**。

---

## 理解图的概念、术语。

**图**是一种数据结构，图中的数据元素通常用项点来表示，而数据元素间的关系用边来表示，故图可定义为:

 图G由两个集合V (G)和E (G)所组成， 记作G= (V, E)， 其中V (G)是图中项点的非空有限集合， E (G)是边的有限集合(边是V (G)中项点的无序对或有序对集合)。

 项点集V (G)不可为空集，边集E (G)可以为空集。若E (G)为空集，则图G只有项点而没有边，称为**零图**。

G1=<V1, E1>

​    V1={v0,V1,V2,V3,V4 }

​    E1={(v0,v1), (v0,v3), (v1,v2), (v1,v4),(v2,V3) (v2,v4)}

![image-20211009152713296](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009152713296.png)

无序对(vi,vj)和(vj,vi),都是表示同一条边.

G1=<V1, E1>

V1={v0 V1,V2 v3}

E1={<V0,V1>, <V0,V2), <v2,V3>, <V3,V0 >}

有序对<vi,vj>用以vi为起点、vj为终点的有向线段表示，称为有向边或弧;

![image-20211009153011512](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009153011512.png)

**无向图**(Undigraph)

如果图中每条边都是项点的无序对，即每条边在图示时都没有箭头，则称此图为无向图。

![image-20211009153317521](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009153317521.png)

**有向图**(Digraph)

如果图中每条边都是项点的有序对，即每条边在图示时都用箭头表示方向，则称此图为有向图。

![image-20211009153535502](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009153535502.png)

 **完全无向图**:

若一个无向图有n个项点，且每一个顶点与其他n-1个顶点之可都有边，这样的图称为无向完全任。

![image-20211009153739369](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009153739369.png)

 **完全有向图**: 

若一个有向图有n个顶点，且每一个顶点与其他n-1个项点之间都有一条以该项点为弧尾的弧，这样的图称为有向完全图。

![](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009154537874.png)

在上述规定下，定点数n和边数e满足下述关系：

​     若G是无向图，则0 <= e <= **n(n-1)/2**；

​     若G是有向图，则0 <= e <= **n(n-1)**；

​     恰好有 **n(n-1)/2** 条边的无向图称为**完全无向图**；

​     恰好有 **n(n-1)** 条边的有向图称为**完全有向图**



**简单路径**

 如果一条路径上所有项点(起始点和终止点除外)彼此都是不同的，则称该路径是简单路径。



**回路(Cycle) 和简单回路**

 在一 条路径中，如果其起始点和终止点是同现点，则称其为回路。

 简单路径相应的回路称为简单回路。



**连通图(Connected Graph)和强连通图**

 在无向图G中，若从Vi到Vj有路径，则称Vi和Vj是连通的。若G中任意两项点都是连通的，则称G是连通图。

 对于有向图而言，若有向图G中每一对不同项点Vi和Vj之间有从Vi到Vj和从Vj到Vi的路径，则称G为强连通图。

![image-20211009155310950](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009155310950.png)

![image-20211009155544962](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009155544962.png)



**连通分量和强连通分量**

连通分量指的是无向图G中的极大连通子图。

强连通分量指的是有向图G中的极大强连通子图。

注意:这里是极大面不是最大。



**度(Degree) 、入度(Indegree)和出度(Outdegree )**

**所谓顶点的度，就是指和该项点相关联的边数。**

  在有向图中，以终止于该项点的弧的数目称为该项点的入度;以起始于该项点的弧的数目称为该项点的出度;某项点的入度和出度之和称为该项点的度。

项点V0的度为3;

项点V1的度为2；

项点V0的入度为1，出度为2，度为3；

项点V1的入度为2，出度为1,度为3;

项点V2的入度为1,出度为1，度为2.

![image-20211009160058546](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009160058546.png)

**权和网(Net)**

 在一个图中， 每条**边**都可以标上具有某种含义的数值，该数值称为该边的**权**。

 边上带**权**的图称为带权图，也称为**网**。

![image-20211009160329008](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009160329008.png)

---



## 掌握图的存储结构（邻接矩阵、邻接表）

邻接矩阵

![image-20211009161114776](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009161114776.png)



![image-20211009161258234](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009161258234.png)

对于带权图(网)的邻接矩阵可以定义为:

![image-20211009162316603](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009162316603.png)

**邻接表同儿子链表表示法**

![image-20211013151237276](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211013151237276.png)

---

## 掌握图的遍历方法（深度优先遍历、广度优先遍历）

 从图的任一顶点出发访问图中的各个项点，并且使**每个项点仅被访问一次**。这一过程叫做**图的遍历**。

 对图的遍历通常采用两种遍历次序，即**深度优先搜索(DFS)和广度优先搜索(BFS).**

  它们对无向图和有向图都适用。



**深度优先搜索(DFS)**

基本思想:  设v的邻接点是w1,w2, …., wm

1. 访问v，
2. 从v的邻接点w1开始深度优先遍历;
3. 从一个未访问邻接点的wk开始深度优先遍历，直至所有与v连通的结点均被访问过。

![image-20211009164708271](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211009164708271.png)

**广度优先搜索**

基本思想是:

1)访问初始点V,并将其标记为己访问过，

2)访问Vi的所有未被访问过的邻接点Vq，V2, ... Vin，并均标记为已访问过，

3)依次访问Vq，V2, ... V,的所有未被访问过的邻接点，并均标记为己访问过，

​      依此类推，直到图中所有和初始点VI有路径相通的项点都被访问过为止。

这种搜索方式类似于树的按层次遍历的过程。

![image-20211013132952697](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211013132952697.png)

​                                                                           	**V0,V1,V2,V3,V4,V5,V6,V7**

---

## 掌握图的最小生成树的算法（ prim 算法、 kruskal 算法）。 

问题:设在n个城市间建立通信网络，要求建设费用尽可能低模型: n个结点的图，结点连线的权表示建设两点问通信线路的费用。在此网络的生成树中找出建设费用最小的生成树。

最小生成树问题，即在连通网中，构造边上的代价总和最小。算法有两种:即**普里姆算法(Prim)和克鲁斯卡尔算法(Kruskal)** 。



普里姆算法(Prim)

![微信图片_20211013133654](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\微信图片_20211013133654.jpg)



克鲁斯卡尔算法(Kruskal)

![fdd70a6a6bd7062bae5499af658d97c](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\fdd70a6a6bd7062bae5499af658d97c.jpg)

---



## 掌握图的单源最短路径的 dijkstra 算法。 

最短路径是指所经过的边上的权值之和为最小的路径，面不是经过的边的数目为最少。

最短路径问题有两个算法:个是求从某个源点到其他各项点的最短路轻的**迪杰斯特拉(Djkstra) 算法**，另一个是求每 对顶点之间的最短路径的弗洛伊德Floyed) 算法。



**迪杰斯特拉(Djkstra) 算法**

![image-20211013134904897](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211013134904897.png)

---



## 查找基本概念

 **查找表(Search Table)** 是由同一类型的数据元素(或记录)构成的集合，

 关键字(Key)是数据元素(或记录)中某个数据项的值，用它可以标识(识别)个 数据元素(或记录)。

 若此关键字可以惟一地标识 个记录，则称此关键字为**主关键字(Primary Key)**。

 **查找(搜索)** :给定个值， 在查找表中确定是否存在一个数据元素(或记录)，其关键字等于给定的值。



查找分为：**静态查找、顺序查找、二分查找、分块查找**

---





### **顺序查找 (Sequential Search) 也称为线性查找**



基本思想:用给定的值与表中各个记录的关键字值逐个进行比较，若找到相等的则查找成功，否则查找不成功，给出找不到的提示信息。



 这种查找方法对顺序存储和链式存储都是适用的。为了表示平均查找次数，定义平均查找长度为: **(n+1)/2**



成功查找的平均查找长度为(n+1)/2.显然不成功查找次数为n+1,其时间复杂度均为**O(n)**。



 顺序查找的优点是:算法简单且适用面广，它对表的结构无任何要求。无论记录是否按关键字的大小有序，其算法均可应用，而且上述讨论对线性链表也同样适用。顺序查找的缺点是:查找效率低，当n较大时，不宜采用顺序查找。

---



### 二分查找



有师序存储的条件下，若各记录是按其关键字值的大小依次存放的，则这个查找表称为**有序表**。

在有序表中可采用**二分法查找** (或称为折半查找)的方法进行查找。



当n足够大时，可近似表示为**log2n(O(logn))**.可 见在查找速度上，二分法查找比顺序查找的速度要快得多，这是**它的主要优点**。当然，使用二分法查找必须是在顺序存储的条件下，且事先必须做到按关键字值排序才行。

顺序查找虽然速度慢，但是对存储结构和记录存放没有更多的限制。在实际应用中应根据具体情况，选择适当的查找算法。

---



### 分块查找



 分块查找又称索引顺序查找，它是顺序查找方法的一种改进方法，是介于顺序查找和二分法查找之间的种折中查找方法。

 它的基本思想是把线性表分成若干块，在每一块中数据元素的存放次序是任意的，但是块与块之间必须有序，即前一块中的最大关键字必须小于后一 块中的最小关键字。

另外还要建立个索引表， 把每块中最大的关键字值按关键字值大小存入索引表，使**索引表保持为有序表**

分块查找的平均查找长度由两个部分组成: ASL= Eb+Ew

​    Eb为确定某一块所需的平均查找长度， E为在块内的平均查找长度。假设线性表中共有n个数据元素，平均分成b块，每块s个数据元素，并假设查找各块概率相等，若在索引表内和块内查找均用顺序查找方法，根号n个

分块查找的速度比顺序查找要快得多，但又不如二分法查找。如果线性表元素个数很多，且被分成的块数b很大时，对索引表的查找可以采用二分法查找，还能进一步提高速度。

**分块查找的优点**是:在线性表中插入或副除一个 元素时，只要找到元素应属于的块，然后在块内进行插入和刷除运算。由于块内元素的存放是任意的，所以插入和删除比较容易，不需要移动大量元素。

 

---



### 散列表



散列法亦称哈希(HASH)法，是在记录的存储位置和它的关键字之间建立一个确定的对应关系H, 使每个关键字和一个惟一的存储位置相对应。

 这些记录或关键字的存储，亦是按照同样的对应关系确定其存储地址，而后按其地址进行存储的，其存储空间称作**散列表(哈希表)**。

由此可见:

散列函数是一个映象，因此散列函数的设定很灵活，只要使得任何键值由此所得的散列函数值都落在表长允许的范围之内即可;

对于不同的键值可能得到相同的散列地址，即K1不等K2,而H(K1) =H (K2)，这种现象称为**散列冲突**。具有相同函数值的键值你该**散列函数的同义词**。



**除留余数法**

取关键字被某个不大于散列表表长m的质数p除后所得余数为散列地址，即对关键字进行取余运算:

​    **H (k) =k%p (pSm)**

这是种最简单也最常用的构造散列函数的方法。

​    注意:在用此法时，对p的选择很重要。若p选得不好，容易产生冲突。

p应取小于或等于表长m的最大素数，才能达到使散列函数值均匀分布的目的。

 

在开放地址法中，从发生冲突的散列地址为d的单元起进行查找空闲单元有多种方法。

**线性探查法、平方探查法、双散列函数探查法**



**散列表的平均查找长度**

散列法是一种直接计算地址的方法， 会引起冲突， 增加了查找时间，由于发生的冲突次数与表的填满程度直接有关，所以引进装填因子a:

 **g= 表中已有的记录数/表的长度**

a标志着表的填满程度。 散列表查找成功的平均直找长度Sn和装填因子a有关。



例题：已知一组关键字为（26，36，41，44，15，68，12，6，51，25），分别用线性探测法和链接法解决散列冲突。构造这组关键字的散列表，散列函数H(K)=K%

为了减少散列冲突，令装填因子a=0.75，因为n=11，散列表长m= n/a = 11 / 0.75 = 14.6,取整15 .既散列表为HTP[0...14]，H(K)=K%P中，P取接近14的最大素数13，即散列函数为H(K)=K%13.

![image-20211013143219570](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\image-20211013143219570.png)

有入26，36，41，38，44后的散列表



 散列表用顺序表实现，线性探查法解决冲突。几种查找方法在等概率下成功查找的平均查找长度:

**线性探测法平均查找长:**

LENhash =(1+5+1+2+2+1+1+1+1+2+3) /11=20/11=1.82



**顺序查找长度:**

LEN= (11+1) /2=6



**二分法查找长度:**

LEN= (1X1+2x2+3X4+4X4)=33/11=3 



---



## 理解排序的基本概念（关键字、内外排序、稳定性、时间效率、空间效率）



排序过程中依据的不同原则，内部排序方法可大致分为**插入排序、交换排序、选择排序、归并排序和基数排序**等五类。

评价排序算法优劣的标准:

一是算法执行时所需的时间

二是执行算法时所需要的附加空间

执行排序的时间复杂性是算法优劣的重要的标志。



若在排序期间具有相同键值的记录的相对位置不变，则称此排序方法是稳定的，否则称为不稳定的。



---



##  掌握选择排序的方法（简单选择排序、堆排序）



选择排序(Selection Sort) 的基本思想是:每一趟从待排序的序列中选出 关键字最小的记录，顺序放在已排好序的子序列的最后，直到全部记录排序完毕。时间复杂度为O(n^2)，是不稳定的算法



**简单选择排序**

![未命名图片](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\未命名图片.png)



堆排序(Heap Sort)是利用堆的特性进行排序。

 堆的定义如下:n个元素的序到为(K, K2 .. K,)，当且仅当满足下列关系时，称之为堆。

 Ki<=K2i, Ki<=K2i+1或Ki>=K2i，Ki>=K2i+1 (i=1, 2, ... n/2)

 若将与此序列对应的一维 数组看成是一棵完全二叉树发层次编号的顺序存储，则堆的含义表明，完全二义树中所有非终端结点的值均不小于(或不大于)其左、右孩子结点的值。因此，堆项元素的值必为序列中的最大值或最小值(即大项堆或小项堆)。

时间复杂度为**O(nlogn)**，是**不稳定**的排序算法

![2](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\2.png)

![3](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\3.png)



---



## 掌握插入排序的方法（直接插入排序）



**插入排序**(Insertion Sort) 的基本思想:每次将一个待排序的记录，按其关键字的大小插入到前面已经排好序的有序序列中的适当位置上，直到全部记录插入完成为止。

![4](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\4.png)

有按插入排序算法简单、 另实现，其法的时间复杂度是**O(n2)**。从空间复杂度来看，只需要一 "记录 大小的辅助空间用于暂存待插入的记录。

 当待排序记录较少时， 排序速度较快，反之，当待排序的记录数量较大时，大量的比较和移动操作将使直接插入排序算法的效率降低;

另外，若当待排序的数据元素基本有序时，排序过程中的记录移动次数会大大减少，从而效率会有所提高。

 直接插入排序是一种**稳定**的排序方法。时间复杂度为**O(n^2)**





### 希尔排序



希尔排序方法又称为**缩小增量排序**(Diminishing Increment Sort)，是对直接插入排序方法的改进。

基本思想:

​    将整个待排序的记录序列划分成若千个子序列，然后分别对每个子序列进行直接插入排序，这样可以减少参与直接插入排序的数据量，如此反复，当经过几次分组排序后，记录的排列已经基本有序，这个时候再对所有的记录进行次直接插入排序。

不稳定的排序算法，时间复杂度为**O(nlogn)**



---



## 掌握交换排序的方法（冒泡排序、快速排序） 



### 冒泡排序

冒泡排序是一种简单的排序方法。

基本思想:对所有相邻记录的关键字值进行比较，如果是逆序(r [i] >r [i+1] )，则交换其位置，经过多趟排序，最终使整个序列有序。

![5](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\5.png)

冒泡排序的时间复杂度为**O(n2)**, 由于它的记录移动次数较多，故平均时间性能比三按面入排序要差得多。

冒泡排序只需要一个记录的辅助空间，用来作为记录交换的中间暂存单元。



冒泡排序是一种**稳定**的排序方法。



### 快速排序



 快速排序(Quick Sort) 是对冒泡排序的一种改进 。

​    基本思想:通过一趟排序将待排序记录划分成两部分， 使得其中一部分记录的关键字比另一部分 记录的关键字小;

   然后再分 别对这两部分记录进行这种排序，直到每个部分为空或只包含一个 记录时，整个快速排序结束。

![6](C:\Users\13282\OneDrive\MarkDown\Data Structure\img\6.png)

时间复杂度为**O(nlogn)**,是**不稳定**的排序算法





<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fstatic.lsd365.com%2Fupload%2Fimage%2Flingsidao%2F20181231%2F1546211882796149.png&refer=http%3A%2F%2Fstatic.lsd365.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1636700607&t=f4fc87766021631240c162c0bb391366">

